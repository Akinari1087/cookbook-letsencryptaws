# letsencryptaws Cookbook

This cookbook is for an implementation of SSL certificate generation and fetching via the Let's Encrypt certificate authority. Certificates are synced from local storage to S3, which is then used by nodes to retrieve the generated certificate. Authentication is done via DNS challenges and automated via Ruby scripts to add and remove TXT records from your domain when required.

## Requirements

- Python 2.7 (for certbot and awscli)
- certbot ACME client
- Domain(s) hosted by AWS Route 53 (only second-level domains, subdomain zones are not supported)
- S3 bucket for storing/retrieving certificate files

### Platforms

Certificate generation:
- Ubuntu

The goal for certificate retrieval is to support Windows but for now, Ubuntu only.

### Cookbooks

- `s3_file` - To grab certificates from S3
- `poise-python` - For grabbing awscli for certificate syncing.

## Usage

### letsencryptaws::default

Set the `certs` attribute as described above and then include this recipe in your cookbook or run_list.

**NOTE** You should manually generate a default certificate (self-signed/fake CA) and place the key, certificate and CA certificate at the `"/#{node['letsencryptaws']['sync_path']}/default-ssl"` path in your S3 sync bucket. These will act as stand-ins for the real certificates/key until they are generated by `letsencryptaws::certbot` after they are first "requested" by a node. So in theory, your real certificates will take up to (chef interval + splay * 3) until they land on the requesting node.

The flow looks like this:
- First Chef run on requesting node. Attribute (`['letsencryptaws']['certs']['example.com'] = []`) gets saved to server (probably created dynamically by a cookbook). Default cert/key gets saved to node from S3.
- Chef run on 'certbot' host. Requests certificate and uploads to S3.
- Second Chef run on requesting node overwrites the previously saved default cert/key with real cert/key from S3.

### letsencryptaws::certbot

This is meant to be run by a single host that manages fetching certificates based on a Chef server `search`. Make sure the instance profile or AWS access keys in the data bag is granted the following permissions on the domains in which you allow certificates to be requested by nodes:

- `route53:ChangeResourceRecordSets`
- `route53:ListHostedZonesByName`
- `route53:GetChange`

### letsencryptaws::import_keystore

This recipe takes certificates and imports them into a Java keystore.

## Attributes

### letsencryptaws::default

For certificate retrieval, just specify what certificates you would like by common name
of the certificate and an array of Subject Alternative Names for the cert. The certificate
may have additional SANs if other nodes request them for the same common name.

<table>
  <tr>
    <th>Key</th>
    <th>Type</th>
    <th>Description</th>
    <th>Default</th>
  </tr>
  <tr>
    <td><tt>normal['letsencryptaws']['certs']</tt></td>
    <td>Hash</td>
    <td>keys are the common name, values are an array of strings that are the SANs for the cert. These all get merged together in the final certificate.</td>
    <td><tt>{}</tt></td>
  </tr>
</table>

### letsencryptaws::import_keystore

This recipe is automatically included if the `import_keystore` hash is not empty.

<table>
  <tr>
    <th>Key</th>
    <th>Type</th>
    <th>Description</th>
    <th>Default</th>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['import_keystore']</tt></td>
    <td>Hash</td>
    <td>keys are full paths to Java keystores, values are an array of primary names of certificates to add to the keystore</td>
    <td><tt>{}</tt></td>
  </tr>
</table>

### letsencryptaws::certbot

<table>
  <tr>
    <th>Key</th>
    <th>Type</th>
    <th>Description</th>
    <th>Default</th>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['config_dir']</tt></td>
    <td>string</td>
    <td>dir where all certbot configuration will be stored, including certs</td>
    <td><tt>/mnt/letsencrypt</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['scripts_dir']</tt></td>
    <td>string</td>
    <td>dir to put Ruby script wrappers that will be used for Route 53 certificate validation</td>
    <td><tt>/mnt/letsencrypt/scripts</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['data_bag']</tt></td>
    <td>string</td>
    <td>Name of data bag used for credentials storage</td>
    <td><tt>nil</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['data_bag_item']</tt></td>
    <td>string</td>
    <td>Name of item within data bag for credentials storage</td>
    <td><tt>nil</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['email']</tt></td>
    <td>string</td>
    <td>Email addressed used for certbot during generation</td>
    <td><tt>nobody@example.com</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['ebs_device']</tt></td>
    <td>string</td>
    <td>device of the ebs volume to mount on `config_dir` (only applies on ec2 instances)</td>
    <td><tt>/dev/xvdf</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['test_certs']</tt></td>
    <td>boolean</td>
    <td>request certs from staging (signed by fake CA, subject to less rate limiting)</td>
    <td><tt>false</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['sync_bucket']</tt></td>
    <td>string</td>
    <td>s3 bucket to sync local certificate directory to</td>
    <td><tt>nil</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['sync_path']</tt></td>
    <td>string</td>
    <td>path on the `sync_bucket` to sync certificate directory to</td>
    <td><tt>letsencrypt</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['kms_key_id']</tt></td>
    <td>string</td>
    <td>UUID of the kms key to use for server-side encryption (optional)</td>
    <td><tt>nil</tt></td>
  </tr>
  <tr>
    <td><tt>['letsencryptaws']['blacklist']</tt></td>
    <td>array of strings</td>
    <td>Exact matches of primary certificate name to prevent generation</td>
    <td><tt>[]</tt></td>
  </tr>
</table>

## Data Bags

A data bag is used to store sensitive credential information for AWS and Java keystores. You can arbitrarily specify the name and item name with `node['letsencryptaws']['data_bag']` and `node['letsencryptaws']['data_bag_item']` attributes.

The keys inside the data bag item can be:

<table>
  <tr>
    <th>Key</th>
    <th>Type</th>
    <th>Description</th>
  </tr>
  <tr>
    <td><tt>aws_access_key_id</tt></td>
    <td>string</td>
    <td>AWS_ACCESS_KEY_ID for storing/fetching certificates from S3</td>
  </tr>
  <tr>
    <td><tt>aws_secret_access_key</tt></td>
    <td>string</td>
    <td>AWS_SECRET_ACCESS_KEY for storing/fetching certificates from S3</td>
  </tr>
  <tr>
    <td><tt>keystore_passwords</tt></td>
    <td>hash</td>
    <td>Keys are paths to Java keystore files, values are the passwords to them. One special key is `default` which will be used as a catch-all password if a keystore does not have a specific entry.</td>
  </tr>
  <tr>
    <td><tt>p12_password</tt></td>
    <td>string</td>
    <td>Password to use when generating pkcs12 keyring files.</td>
  </tr>
</table>

## License and Authors

Authors: Matt Kulka <matt@lqx.net>
